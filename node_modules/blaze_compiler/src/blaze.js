require('source-map-support').install();

var fs = require("fs");
var tv4 = require('tv4');
var expression = require('../src/expression');
var schema = require('../src/schema');
var path = require('path');
var Json = require('source-processor');
var error = require('source-processor');

exports.debug = false;

function load_yaml(filepath) {
    var yaml_text = fs.readFileSync(filepath, { encoding: 'utf8' }).toString();
    return Json.parse_yaml(yaml_text);
}
exports.load_yaml = load_yaml;

function load_json(filepath) {
    var json_text = fs.readFileSync(filepath, { encoding: 'utf8' }).toString();
    return Json.parse(json_text);
}
exports.load_json = load_json;

function load_yaml_collection(filepath, cb) {
    var yaml_text = fs.readFileSync(filepath, { encoding: 'utf8' }).toString();
    Json.parse_yaml_collection(yaml_text, cb);
}
exports.load_yaml_collection = load_yaml_collection;

exports.root = path.dirname(fs.realpathSync(__filename)) + "/../";
exports.rules_schema = exports.load_yaml(exports.root + "schema/security_rules.yaml");

function validate_rules(rules) {
    tv4.addSchema("http://firebase.com/schema/types/object#", this.load_yaml(exports.root + "schema/types/object.yaml").toJSON());
    tv4.addSchema("http://firebase.com/schema/types/string#", this.load_yaml(exports.root + "schema/types/string.yaml").toJSON());
    tv4.addSchema("http://firebase.com/schema/types/boolean#", this.load_yaml(exports.root + "schema/types/boolean.yaml").toJSON());
    tv4.addSchema("http://firebase.com/schema/types/number#", this.load_yaml(exports.root + "schema/types/number.yaml").toJSON());
    tv4.addSchema("http://firebase.com/schema/types/any#", this.load_yaml(exports.root + "schema/types/any.yaml").toJSON());

    tv4.addSchema("http://firebase.com/schema#", this.load_yaml(exports.root + "schema/schema.yaml").toJSON());
    tv4.addSchema("http://json-schema.org/draft-04/schema#", fs.readFileSync(exports.root + "schema/jsonschema", { encoding: 'utf8' }).toString());

    var valid = tv4.validate(rules.toJSON(), this.rules_schema.toJSON(), true, true);
    if (!valid) {
        throw error.validation(rules, this.rules_schema, "blaze file", "blaze schema", tv4.error).source(rules.lookup(tv4.error.dataPath.split("/"))).on(new Error());
    }

    if (tv4.getMissingUris().length != 0) {
        throw error.missingURI(tv4.getMissingUris()).on(new Error());
    }

    return valid;
}
exports.validate_rules = validate_rules;

var SchemaRoot = (function () {
    function SchemaRoot(json) {
        this.json = json;
    }
    SchemaRoot.parse = function (json) {
        if (json == null) {
            json = new Json.JObject();
        }
        return new SchemaRoot(json);
    };
    return SchemaRoot;
})();
exports.SchemaRoot = SchemaRoot;

var AccessEntry = (function () {
    function AccessEntry() {
        this.read = expression.Expression.FALSE;
        this.write = expression.Expression.FALSE;
    }
    AccessEntry.parse = function (json) {
        var accessEntry = new AccessEntry();
        accessEntry.location = json.getOrThrow("location", "all access entries require a location to be defined").asString().value.split("/");

        while (accessEntry.location[0] === '') {
            accessEntry.location.shift();
        }

        if (accessEntry.location[accessEntry.location.length - 1] == "") {
            accessEntry.location.pop();
        }

        if (json.has("read")) {
            accessEntry.read = expression.Expression.parseUser(json.getOrThrow("read", "").coerceString());
        }
        if (json.has("write")) {
            accessEntry.write = expression.Expression.parseUser(json.getOrThrow("write", "").coerceString());
        }

        return accessEntry;
    };

    AccessEntry.prototype.match = function (location) {
        if (this.location.length > location.length)
            return false;

        for (var idx in this.location) {
            if (!this.matchSegment(this.location[idx], location[idx]))
                return false;
        }

        return true;
    };

    AccessEntry.prototype.isChildOf = function (location) {
        if (this.location.length <= location.length)
            return false;
        for (var idx in location) {
            if (!this.matchSegment(this.location[idx], location[idx]))
                return false;
        }
        return true;
    };

    AccessEntry.prototype.matchSegment = function (rule_segment, path_segment) {
        if (rule_segment.indexOf("~$") == 0)
            rule_segment = rule_segment.substr(1);
        if (path_segment.indexOf("~$") == 0)
            path_segment = path_segment.substr(1);
        if (rule_segment.indexOf("$") == 0 && path_segment.indexOf("$") == 0)
            return true;

        return rule_segment == path_segment;
    };

    AccessEntry.prototype.getReadFor = function (symbols, path) {
        var base_read = expression.Expression.parse(this.read.expandFunctions(symbols));
        for (var i = 0; i < path.length - this.location.length; i++) {
            var rewrite = base_read.rewriteForChild();
            base_read = expression.Expression.parse(rewrite);
        }
        return base_read;
    };

    AccessEntry.prototype.getWriteFor = function (symbols, path) {
        var base_write = expression.Expression.parse(this.write.expandFunctions(symbols));
        for (var i = 0; i < path.length - this.location.length; i++) {
            base_write = expression.Expression.parse(base_write.rewriteForChild());
        }
        return base_write;
    };
    return AccessEntry;
})();
exports.AccessEntry = AccessEntry;

var Access = (function () {
    function Access() {
    }
    Access.parse = function (json) {
        var access = new Access();
        if (json == null)
            return access;

        json.asArray().forEachIndexed(function (entry, id) {
            var accessEntry = AccessEntry.parse(entry);
            access[id] = (accessEntry);
        });
        return access;
    };

    Access.getChildren = function (self, path) {
        var children = [];
        for (var i = 0; self[i] != undefined; i++) {
            var rule = self[i];
            if (rule.isChildOf(path))
                children.push(rule);
        }
        return children;
    };
    return Access;
})();
exports.Access = Access;

var Rules = (function () {
    function Rules() {
        this.code = null;
    }
    Rules.parse = function (json) {
        var rules = new Rules();
        rules.functions = expression.Functions.parse(json.getOrNull("functions"));
        rules.schema = SchemaRoot.parse(json.getOrNull("schema"));
        rules.access = Access.parse(json.getOrWarn("access", "no access list defined, this Firebase will be inactive"));
        return rules;
    };

    Rules.prototype.inflateSchema = function () {
        this.inflateSchemaRecursive(this.schema.json.asObject(), [], {});
    };

    Rules.prototype.inflateSchemaRecursive = function (json, path, memoization) {
        if (memoization[path.join("/")])
            return;
        else {
            memoization[path.join("/")] = true;
        }

        var children = Access.getChildren(this.access, path);

        children.map(function (child) {
            var childSegment = child.location[path.length];

            var schemaChild = null;
            if (childSegment.indexOf("~$") == 0 || childSegment.indexOf("$") == 0) {
                var wildKey = schema.getWildchild(json);
                if (wildKey == null) {
                    schemaChild = new Json.JObject();
                    console.error("WARNING: " + child.location.join("/") + " in access rule but not in a schema");
                    json.put(new Json.JString(childSegment, -1, -1), schemaChild);
                } else {
                    schemaChild = json.getOrThrow(wildKey.getString(), "error");
                }
            } else {
                var properties = json.getOrNull("properties");
                if (properties == null) {
                    properties = new Json.JObject();
                    json.put(new Json.JString("properties", -1, -1), properties);
                }

                schemaChild = properties.asObject().getOrNull(childSegment);
                if (schemaChild == null) {
                    console.error("WARNING: " + child.location.join("/") + " in access rule but not in a schema");
                    schemaChild = new Json.JObject();
                    properties.asObject().put(new Json.JString(childSegment, -1, -1), schemaChild);
                }
            }

            this.inflateSchemaRecursive(schemaChild, child.location.slice(0, path.length + 1), memoization);
        }, this);
    };
    return Rules;
})();
exports.Rules = Rules;
//# sourceMappingURL=blaze.js.map
