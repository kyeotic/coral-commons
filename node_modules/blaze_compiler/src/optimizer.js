require('source-map-support').install();
var falafel = require("falafel");

function optimize(javascript_str) {
    var current_length = javascript_str.length + 1;
    while (javascript_str.length < current_length) {
        current_length = javascript_str.length;
        var current = javascript_str;

        javascript_str = exports.simplify(exports.parentIsObjectCheckRemoval(exports.clauseRepetitionElimination(exports.childParentAnnihilation(exports.pruneBooleanLiterals(javascript_str)))));
    }
    return current;
}
exports.optimize = optimize;

function optimizeAndTrim(javascript_str) {
    var optimized = exports.optimize(javascript_str);
    optimized = optimized.replace(/^\(+true\)+$/, "true");
    optimized = optimized.replace(/^\(+false\)+$/, "false");
    return optimized;
}
exports.optimizeAndTrim = optimizeAndTrim;

var simplifyMemory = {};

function simplify(javascript_str) {
    if (simplifyMemory[javascript_str])
        return simplifyMemory[javascript_str];

    var simplify_fn = function (node) {
        node.precedence = 1000;
        if (node.type == "BinaryExpression" || node.type == "BooleanExpression" || node.type == "LogicalExpression") {
            node.precedence = js_precedence(node.operator);
            var LHS, RHS;
            if (node.left.precedence >= node.precedence) {
                LHS = node.left.source();
            } else if (node.left.precedence < node.precedence) {
                LHS = "(" + node.left.source() + ")";
            }

            if (node.right.precedence == node.precedence && isCommunicativeUniquePrecedence(node.operator)) {
                RHS = node.right.source();
            } else if (node.right.precedence > node.precedence) {
                RHS = node.right.source();
            } else if (node.right.precedence <= node.precedence) {
                RHS = "(" + node.right.source() + ")";
            }
            node.update(LHS + node.operator + RHS);
        }
    };

    var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();
    simplifyMemory[javascript_str] = result;
    return result;
}
exports.simplify = simplify;

var pruneBooleanLiteralsMemory = {};

function pruneBooleanLiterals(javascript_str) {
    if (pruneBooleanLiteralsMemory[javascript_str])
        return pruneBooleanLiteralsMemory[javascript_str];
    var simplify_fn = function (node) {
        if (node.type == "UnaryExpression") {
            if (node.operator == '!' && node.argument.type == 'Literal') {
                node.update(!node.argument.value);
            }
        } else if (node.type == "LogicalExpression") {
            node.left.is = function (val) {
                return node.left.type == 'Literal' && node.left.value == val;
            };
            node.right.is = function (val) {
                return node.right.type == 'Literal' && node.right.value == val;
            };

            if (node.operator == '&&' && node.left.is(true) && node.right.is(true)) {
                node.update("true");
            } else if (node.operator == '&&' && node.left.is(false)) {
                node.update("false");
            } else if (node.operator == '&&' && node.right.is(false)) {
                node.update("false");
            } else if (node.operator == '&&' && node.left.is(true)) {
                node.update("(" + node.right.source() + ")");
            } else if (node.operator == '&&' && node.right.is(true)) {
                node.update("(" + node.left.source() + ")");
            } else if (node.operator == '||' && node.left.is(false) && node.right.is(false)) {
                node.update("false");
            } else if (node.operator == '||' && node.left.is(true)) {
                node.update("true");
            } else if (node.operator == '||' && node.right.is(true)) {
                node.update("true");
            } else if (node.operator == '||' && node.left.is(false)) {
                node.update("(" + node.right.source() + ")");
            } else if (node.operator == '||' && node.right.is(false)) {
                node.update("(" + node.left.source() + ")");
            }
        }
    };

    var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();
    pruneBooleanLiteralsMemory[javascript_str] = result;
    return result;
}
exports.pruneBooleanLiterals = pruneBooleanLiterals;

var clauseRepetitionEliminationMemory = {};

function clauseRepetitionElimination(javascript_str) {
    if (clauseRepetitionEliminationMemory[javascript_str])
        return clauseRepetitionEliminationMemory[javascript_str];

    var simplify_fn = function (node) {
        if (node.type == "LogicalExpression") {
            if (node.parent.type == "LogicalExpression" && node.parent.operator == node.operator) {
            } else {
                var operator = node.operator;
                var clauses = [];
                var logical = node;

                while (logical.type == "LogicalExpression" && logical.operator == operator) {
                    clauses.push(logical.right.source());
                    logical = logical.left;
                }
                clauses.push(logical.source());
                var clauses = clauses.reverse();

                for (var primaryClause = 0; primaryClause < clauses.length; primaryClause++) {
                    for (var repeatClause = primaryClause + 1; repeatClause < clauses.length; repeatClause++) {
                        if (clauses[primaryClause] == clauses[repeatClause]) {
                            clauses.splice(repeatClause, 1);
                            repeatClause--;
                        }
                    }
                }

                node.update(exports.simplify("((" + clauses.join(")" + operator + "(") + "))"));
            }
        }
    };

    var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();
    clauseRepetitionEliminationMemory[javascript_str] = result;
    return result;
}
exports.clauseRepetitionElimination = clauseRepetitionElimination;

var childParentAnnihilationMemory = {};

function childParentAnnihilation(javascript_str) {
    if (childParentAnnihilationMemory[javascript_str])
        return childParentAnnihilationMemory[javascript_str];

    var simplify_fn = function (node) {
        if (node.type == 'MemberExpression' && node.object.type == 'CallExpression' && node.object.arguments.length == 0 && node.object.callee.type == 'MemberExpression' && node.object.callee.property.type == 'Identifier' && node.object.callee.property.name == 'parent' && node.object.callee.object.type == 'CallExpression' && node.object.callee.object.callee.type == 'MemberExpression' && node.object.callee.object.callee.property.type == 'Identifier' && node.object.callee.object.callee.property.name == 'child') {
            node.object.update(node.object.callee.object.callee.object.source());
        }
    };

    var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();
    childParentAnnihilationMemory[javascript_str] = result;
    return result;
}
exports.childParentAnnihilation = childParentAnnihilation;

var parentIsObjectCheckRemovalMemory = {};

var parent_pattern = /^!newData(\.parent\(\))+\.exists\(\)\|\|newData(\.parent\(\))+\.hasChildren\(\)$/;
function parentIsObjectCheckRemoval(javascript_str) {
    if (parentIsObjectCheckRemovalMemory[javascript_str])
        return parentIsObjectCheckRemovalMemory[javascript_str];

    var simplify_fn = function (node) {
        if (node.type == 'LogicalExpression' && node.operator == '||') {
            var match = parent_pattern.exec(node.source());
            if (match != null && match[1] == match[2]) {
                node.update("true");
            }
        }
    };

    var result = falafel(javascript_str.toString(), {}, simplify_fn).toString();
    parentIsObjectCheckRemovalMemory[javascript_str] = result;
    return result;
}
exports.parentIsObjectCheckRemoval = parentIsObjectCheckRemoval;

var singleQuoteRegex = new RegExp("'", "g");

function escapeSingleQuotes(string_literal) {
    string_literal = string_literal.replace(singleQuoteRegex, "\\'");
    return string_literal;
}
exports.escapeSingleQuotes = escapeSingleQuotes;

var escapeRegex = new RegExp("\\\\", "g");

function escapeEscapes(string_literal) {
    string_literal = string_literal.replace(escapeRegex, "\\\\");
    return string_literal;
}
exports.escapeEscapes = escapeEscapes;

function sanitizeQuotes(javascript_str) {
    var simplify_fn = function (node) {
        if (node.type == "Literal") {
            if (node.raw.indexOf('"') == 0)
                node.update("'" + exports.escapeSingleQuotes(node.value) + "'");
        }
    };

    return falafel(javascript_str.toString(), {}, simplify_fn).toString();
}
exports.sanitizeQuotes = sanitizeQuotes;

var isCommunicativeUniquePrecedence = function (token) {
    switch (token) {
        case '||':
        case '&&':
        case '&':
        case '|':
            return true;
        default:
            return false;
    }
};

var js_precedence = function (token) {
    switch (token) {
        case '||':
            return 1;
        case '&&':
            return 2;
        case '|':
            return 3;
        case '^':
            return 4;
        case '&':
            return 5;
        case '==':
        case '!=':
        case '===':
        case '!==':
            return 6;
        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            return 7;
        case '<<':
        case '>>':
        case '>>>':
            return 8;
        case '+':
        case '-':
            return 9;
        case '*':
        case '/':
        case '%':
            return 11;
        default:
            return 0;
    }
};
//# sourceMappingURL=optimizer.js.map
