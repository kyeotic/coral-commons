require('source-map-support').install();
var falafel = require("falafel");

var XRegExp = require('xregexp').XRegExp;

var error = require('source-processor');
var optimizer = require('../src/optimizer');
var globals = require('../src/globals');

var Function = (function () {
    function Function(declaration, expression) {
        var match = XRegExp.exec(declaration, Function.DECLARATION_FORMAT);
        var params = XRegExp.split(match.paramlist, /\s*,\s*/);

        if (params.length == 1 && params[0] == '')
            params = [];

        this.identifier = match.name;
        this.signature = match.name + "(" + params.length + ")";

        this.parameter_map = params;

        this.expression = Expression.parseUser(expression);
    }
    Function.parse = function (json) {
        var fun;

        json.asObject().forEach(function (key, val) {
            fun = new Function(key.asString().value, val.coerceString());
        });

        return fun;
    };
    Function.DECLARATION_FORMAT = XRegExp('(?<name>\\w+) \\s* # name is alphanumeric\n' + '\\( \\s*  #open brace for function args  \n' + '(?<paramlist> (\\w+\\s*(,\\s*\\w+\\s*)*)?) #comma seperated list of params\n' + '\\) \\s*  #close brace for function args \n', 'gx');
    return Function;
})();
exports.Function = Function;

var Functions = (function () {
    function Functions() {
    }
    Functions.parse = function (json) {
        var functions = new Functions();
        if (json == null)
            return functions;

        json.asArray().forEach(function (val) {
            var fun = Function.parse(val);
            functions[fun.identifier] = fun;
        });
        return functions;
    };
    return Functions;
})();
exports.Functions = Functions;

var Symbols = (function () {
    function Symbols() {
        this.functions = {};
        this.variables = {};
    }
    Symbols.prototype.clone = function () {
        var clone = new Symbols();
        for (var p in this.functions)
            clone.functions[p] = this.functions[p];
        for (var v in this.variables)
            clone.variables[v] = this.variables[v];
        return clone;
    };

    Symbols.prototype.loadFunction = function (functions) {
        for (var identifier in functions) {
            this.functions[identifier] = functions[identifier];
        }
    };
    return Symbols;
})();
exports.Symbols = Symbols;

var Expression = (function () {
    function Expression(raw, source) {
        this.raw = raw;
        this.source = source;
    }
    Expression.parse = function (raw) {
        return new Expression(raw, null);
    };

    Expression.parseUser = function (json) {
        return new Expression(optimizer.sanitizeQuotes(json.value), json);
    };

    Expression.prototype.rewriteForChild = function () {
        var falafel_visitor = function (node) {
            if (node.type == "Identifier") {
                if (node.name == "next") {
                    node.update("next.parent()");
                } else if (node.name == "prev") {
                    node.update("prev.parent()");
                }
            }
        };

        return falafel(this.raw, {}, falafel_visitor).toString();
    };

    Expression.prototype.rewriteForParent = function (child_name) {
        if (child_name.indexOf("$") == 0)
            return "false";
        if (child_name.indexOf("~$") == 0)
            return "true";

        var falafel_visitor = function (node) {
            if (node.type == "Identifier") {
                if (node.name == "next") {
                    node.update("next['" + child_name + "']");
                } else if (node.name == "prev") {
                    node.update("prev['" + child_name + "']");
                }
            }
        };

        return falafel(this.raw, {}, falafel_visitor).toString();
    };

    Expression.prototype.expandFunctions = function (symbols) {
        var self = this;
        var falafel_visitor = function (node) {
            if (node.type == "Identifier") {
                if (symbols.functions[node.name]) {
                    node.expr_type = "pred";
                } else if (symbols.variables[node.name]) {
                    node.update(symbols.variables[node.name].source());
                    node.expr_type = symbols.variables[node.name].expr_type;
                }
            } else if (node.type == "CallExpression") {
                if (node.callee.expr_type === "pred") {
                    var fun = symbols.functions[node.callee.name];

                    var function_symbols = symbols.clone();

                    var params = node.arguments;
                    for (var p_index in params) {
                        var p_node = params[p_index];
                        var local_name = fun.parameter_map[p_index];
                        function_symbols.variables[local_name] = p_node;
                    }

                    var expansion = fun.expression.expandFunctions(function_symbols);

                    node.update("(" + expansion + ")");
                    node.expr_type = "value";
                }
            }
        };

        var code = falafel(this.raw, {}, falafel_visitor).toString();

        return optimizer.simplify(code);
    };

    Expression.prototype.generate = function (symbols) {
        var self = this;

        var falafel_visitor = function (node) {
            if (node.type == "Identifier") {
                if (node.name == "data") {
                    node.expr_type = "rule";
                } else if (node.name == "newData") {
                    node.expr_type = "rule";
                } else if (node.name == "next") {
                    node.update("newData");
                    node.expr_type = "rule";
                } else if (node.name == "prev") {
                    node.update("data");
                    node.expr_type = "rule";
                } else if (node.name == "root") {
                    node.expr_type = "rule";
                } else if (node.name.indexOf("$") == 0) {
                    node.expr_type = "value";
                } else if (node.name == "auth") {
                    node.expr_type = "map";
                } else if (symbols.functions[node.name]) {
                    node.expr_type = "pred";
                } else if (symbols.variables[node.name]) {
                    var label = node.name;
                    node.update(symbols.variables[node.name].source());
                    node.expr_type = symbols.variables[node.name].expr_type;
                    node.label = label;
                }
            } else if (node.type == "Literal") {
                if ((typeof node.value == 'string' || node.value instanceof String) && node.raw.indexOf('/') == 0) {
                    node.expr_type = "regex";
                } else {
                    node.expr_type = "value";
                }
            } else if (node.type == "ArrayExpression") {
                node.expr_type = "value";
            } else if (node.type == "MemberExpression") {
                if (node.object.expr_type == "rule") {
                    node.expr_type = null;

                    if (node.property.type == 'Identifier') {
                        if (node.property.name == 'val') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'parent') {
                            node.expr_type = "fun():rule";
                        } else if (node.property.name == 'hasChildren') {
                            node.expr_type = "fun(array):value";
                        } else if (node.property.name == 'hasChild') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'isString') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'isBoolean') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'isNumber') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'exists') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'now') {
                            node.expr_type = "value";
                        } else if (node.property.name == 'getPriority') {
                            node.expr_type = "fun():value";
                        } else if (node.property.expr_type == 'rule') {
                            node.update(node.object.source() + ".child(" + node.property.source() + ".val())");
                            node.expr_type = "rule";
                        } else if (node.property.expr_type == 'value') {
                            if (node.property.label && !isArraySyntaxMemberExpression(node)) {
                                node.update(node.object.source() + ".child('" + node.property.label + "')");
                            } else {
                                node.update(node.object.source() + ".child(" + node.property.source() + ")");
                            }
                            node.expr_type = "rule";
                        } else {
                            node.update(node.object.source() + ".child('" + node.property.source() + "')");
                            node.expr_type = "rule";
                        }
                    } else if (node.property.expr_type == 'rule') {
                        node.update(node.object.source() + ".child(" + node.property.source() + ".val())");
                        node.expr_type = "rule";
                    } else if (node.property.expr_type == 'value') {
                        node.update(node.object.source() + ".child(" + node.property.source() + ")");
                        node.expr_type = "rule";
                    }
                } else if (node.object.expr_type == "map") {
                    node.expr_type = "value";
                } else if (node.object.expr_type == "value") {
                    node.expr_type = "value";

                    if (node.property.type == 'Identifier') {
                        if (node.property.name == 'contains') {
                            node.expr_type = "fun(value):value";
                        } else if (node.property.name == 'replace') {
                            node.expr_type = "fun(value,value):value";
                        } else if (node.property.name == 'toLowerCase') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'toUpperCase') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'beginsWith') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'endsWith') {
                            node.expr_type = "fun():value";
                        } else if (node.property.name == 'matches') {
                            node.expr_type = "fun(regex):value";
                        }
                    }
                }
                if (node.expr_type == null) {
                    throw error.message("Bug: 3 Unexpected situation in type system " + node.object.expr_type + " " + node.property.expr_type).source(self.source).on(new Error());
                }
            } else if (node.type == "CallExpression") {
                if (node.callee.expr_type === "fun():rule") {
                    node.expr_type = "rule";
                } else if (node.callee.expr_type === "fun():value") {
                    node.expr_type = "value";
                } else if (node.callee.expr_type === "fun(array):rule") {
                    node.expr_type = "value";
                } else if (node.callee.expr_type === "fun(value):value") {
                    node.expr_type = "value";
                } else if (node.callee.expr_type === "fun(array):value") {
                    node.expr_type = "value";
                } else if (node.callee.expr_type === "fun(regex):value") {
                    node.expr_type = "value";
                } else if (node.callee.expr_type === "fun(value,value):value") {
                    node.expr_type = "value";
                } else if (node.callee.expr_type === "pred") {
                    var fun = symbols.functions[node.callee.name];

                    var function_symbols = symbols.clone();

                    var params = node.arguments;
                    for (var p_index in params) {
                        var p_node = params[p_index];
                        var local_name = fun.parameter_map[p_index];
                        function_symbols.variables[local_name] = p_node;
                    }

                    var expansion = fun.expression.generate(function_symbols);

                    node.update("(" + expansion + ")");
                    node.expr_type = "value";
                } else {
                    if (node.callee.type == 'MemberExpression' && node.callee.property.type == 'Identifier' && node.callee.property.name == 'child') {
                        throw error.message("parent.child(<name>) syntax is not supported in Blaze, use parent.<name> or parent[<name>] instead").source(self.source).on(new Error());
                    } else {
                        var uncoerced = [
                            'contains',
                            'toLowerCase',
                            'replace',
                            'toUpperCase',
                            'beginsWith',
                            'endsWith',
                            'matches'
                        ];
                        if (node.callee.property != null && uncoerced.indexOf(node.callee.property.name) >= 0) {
                            throw error.message("Unexpected situation in type system on '" + node.source() + "', (you probably forgot to use .val() before using an inbuilt method)").source(self.source).on(new Error());
                        } else {
                            throw error.message("Bug: 4 Unexpected situation in type system on '" + node.callee.expr_type + "'").source(self.source).on(new Error());
                        }
                    }
                }
            } else if (node.type == "BinaryExpression" || node.type == "BooleanExpression" || node.type == "LogicalExpression") {
                if (node.left.expr_type === "rule") {
                    node.left.update(node.left.source() + ".val()");
                }

                if (node.right.expr_type === "rule") {
                    node.right.update(node.right.source() + ".val()");
                }

                node.expr_type = "value";
            } else if (node.type == "UnaryExpression") {
                node.expr_type = node.argument.expr_type;
            } else if (node.type == "ExpressionStatement") {
            } else if (node.type == "Program") {
            } else {
                throw error.message("Bug: 5 Unrecognised Type In Expression Parser: " + node.type).source(self.source).on(new Error());
            }
        };

        var code = falafel(this.raw, {}, falafel_visitor).toString();

        return globals.optimize ? optimizer.optimizeAndTrim(code) : optimizer.simplify(code);
    };
    Expression.FALSE = new Expression("false", null);
    Expression.TRUE = new Expression("true", null);
    return Expression;
})();
exports.Expression = Expression;

function isArraySyntaxMemberExpression(node) {
    return node.source().slice(node.object.source().length).trim().charAt(0) == '[';
}
//# sourceMappingURL=expression.js.map
