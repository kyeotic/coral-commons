require('source-map-support').install();

var blaze = require('./blaze');
var expression = require('../src/expression');
var tv4 = require('tv4');
var fs = require('fs');
var Json = require('source-processor');
var error = require('source-processor');
var optimizer = require('../src/optimizer');
var globals = require('../src/globals');

var debug_metaschema_validation = false;

function annotate(model) {
    model.schema.root = annotate_schema(model.schema.json, null, null, new SchemaAPI(), model);
}
exports.annotate = annotate;

function pushDownConstraints(model) {
    model.schema.root.pushDownConstraints(model.functions, null);
}
exports.pushDownConstraints = pushDownConstraints;

function pullUpConstraints(model) {
    model.schema.root.pullUpConstraints(model.functions, "");
}
exports.pullUpConstraints = pullUpConstraints;

function combineACL(model) {
    model.schema.root.combineACL(model.functions, model.access, []);
}
exports.combineACL = combineACL;

function generateRules(model) {
    var buffer = [];
    buffer.push('{\n');
    buffer.push('  "rules":');

    var symbols = new expression.Symbols();
    symbols.loadFunction(model.functions);

    model.schema.root.generate(symbols, "  ", buffer, false);
    buffer.push('}\n');

    var code = buffer.join('');
    return code;
}
exports.generateRules = generateRules;

var SchemaNode = (function () {
    function SchemaNode(node) {
        this.properties = {};
        this.node = node;
    }
    SchemaNode.prototype.isLeaf = function () {
        return Object.keys(this.properties).length == 0;
    };

    SchemaNode.prototype.generate = function (symbols, prefix, buffer, use_validation) {
        buffer.push('{\n');

        if (this.indexOn.length > 0) {
            buffer.push(prefix + '  ".indexOn": ["' + this.indexOn.join('", "') + '"],\n');
        }

        buffer.push(prefix + '  ".write":"');
        buffer.push(optimizer.escapeEscapes(this.write.generate(symbols)));
        buffer.push('",\n');

        if (use_validation) {
            buffer.push(prefix + '  ".validate":"');
            buffer.push(optimizer.escapeEscapes(this.write.generate(symbols)));
            buffer.push('",\n');
        }

        buffer.push(prefix + '  ".read":"');
        buffer.push(optimizer.escapeEscapes(this.read.generate(symbols)));
        buffer.push('",\n');

        var comma_in_properties = false;

        for (var property in this.properties) {
            if (property.indexOf("~$") == 0) {
                var name = property.substr(1);
                var use_validation_child = true;
            } else {
                var name = property;
                var use_validation_child = false;
            }

            buffer.push(prefix + '  "' + name + '": ');
            this.properties[property].generate(symbols, prefix + "  ", buffer, use_validation_child);
            buffer.pop();
            buffer.push('},\n');
            comma_in_properties = true;
        }

        if (!this.additionalProperties) {
            buffer.push(prefix + '  "$other":{".validate":"false"');
            buffer.push('GETS REMOVED BY CODE BELOW');
            comma_in_properties = true;
        }

        if (comma_in_properties) {
            buffer.pop();
            buffer.push("}\n");
        } else {
            buffer.pop();
            buffer.push('"\n');
        }

        buffer.push(prefix);
        buffer.push("}\n");

        return buffer;
    };

    SchemaNode.prototype.pushDownConstraints = function (functions, inherited_clause) {
        var symbols = new expression.Symbols();
        symbols.loadFunction(functions);

        if (inherited_clause != null) {
            this.constraint = expression.Expression.parse("(" + inherited_clause.rewriteForChild() + ")&&(" + this.constraint.expandFunctions(symbols) + ")");
        }

        for (var property in this.properties) {
            this.properties[property].pushDownConstraints(functions, this.constraint);
        }
    };

    SchemaNode.prototype.pullUpConstraints = function (functions, child_name) {
        if (this.isLeaf())
            return this.constraint.rewriteForParent(child_name);

        var symbols = new expression.Symbols();
        symbols.loadFunction(functions);
        var children_clauses = this.constraint.expandFunctions(symbols);

        for (var property in this.properties) {
            children_clauses = "(" + children_clauses + ") && (" + this.properties[property].pullUpConstraints(functions, property) + ")";
        }

        this.constraint = expression.Expression.parse(children_clauses);

        return this.constraint.rewriteForParent(child_name);
    };

    SchemaNode.prototype.combineACL = function (functions, acl, location) {
        var write = "false";
        var read = "false";

        var symbols = new expression.Symbols();
        symbols.loadFunction(functions);

        for (var idx in acl) {
            var entry = acl[idx];

            if (entry.match(location)) {
                write = "(" + write + ")||(" + entry.getWriteFor(symbols, location).raw + ")";
                read = "(" + read + ")||(" + entry.getReadFor(symbols, location).raw + ")";
            }
        }

        this.write = expression.Expression.parse("(" + this.constraint.raw + ")&&(" + write + ")");
        this.read = expression.Expression.parse(read);

        for (var property in this.properties) {
            var child_location = location.concat(property);
            this.properties[property].combineACL(functions, acl, child_location);
        }
    };

    SchemaNode.prototype.getWildchild = function () {
        return exports.getWildchild(this.node).value;
    };
    SchemaNode.KEY_PATTERN = ".*";
    return SchemaNode;
})();
exports.SchemaNode = SchemaNode;

var MetaSchema = (function () {
    function MetaSchema() {
    }
    MetaSchema.prototype.validate = function (data) {
        if (debug_metaschema_validation) {
            console.log("validating data");
            console.log(data.toJSON());
            console.log("with schema");
            console.log(this.validator.toJSON());
        }

        var valid = tv4.validate(data.toJSON(), this.validator.toJSON(), true, true);

        if (!valid) {
            throw error.validation(data, this.validator, "schema node", "type schema", tv4.error).source(data).on(new Error());
        } else {
            if (debug_metaschema_validation)
                console.log("passed validation");
        }

        if (tv4.getMissingUris().length != 0) {
            throw error.message("missing $ref definitions: " + tv4.getMissingUris()).source(data).on(new Error());
        }

        return valid;
    };

    MetaSchema.parse = function (json) {
        var result = new MetaSchema();
        result.validator = json.getOrThrow("validator", "no validator defined for the metaschema");
        result.compile = new Function("api", json.getOrThrow("compile", "no compile defined for the metaschema").asString().value);

        return result;
    };
    return MetaSchema;
})();
exports.MetaSchema = MetaSchema;

function annotate_schema(node, parent, key, api, model) {
    if (node.has("$ref")) {
        node = exports.fetchRef(node.getOrThrow("$ref", "").coerceString().value, model);

        if (key.indexOf("$") == 0 || key.indexOf("~$") == 0) {
            parent.asObject().put(new Json.JString(key, -1, -1), node);
        } else {
            parent.asObject().getOrThrow("properties", "no properties defined above reference with key:" + key).asObject().put(new Json.JString(key, -1, -1), node);
        }
    }

    var annotation = new SchemaNode(node);

    if (node.has("properties")) {
        node.getOrThrow("properties", "").asObject().forEach(function (name, child) {
            if (name.value.indexOf("$") == 0 || name.value.indexOf("~$") == 0)
                throw error.message("properties cannot start with $ or ~$, you probably want a wild(er)child which is not declared in the properties section").source(name).on(new Error());

            annotation.properties[name.value] = annotate_schema(child, node, name.getString(), api, model);
        });
    }

    if (globals.debug)
        console.log("annotate_schema", node.toJSON());

    if (exports.getWildchild(node)) {
        var wildname = exports.getWildchild(node).value;
        var wildkey = exports.getWildchild(node);

        annotation.properties[wildname] = annotate_schema(node.getOrThrow(wildname, "cant find wildchild"), node, wildname, api, model);

        var patternProperties = new Json.JObject();

        node.asObject().put(new Json.JString("patternProperties", wildkey.start.position, wildkey.end.position), patternProperties);

        patternProperties.put(new Json.JString(SchemaNode.KEY_PATTERN, 0, 0), node.getOrThrow(wildname, "cant find wildchild"));
    } else {
    }

    api.setContext(node, parent, annotation, model);
    annotation.type = node.has("type") ? node.getOrThrow("type", "").asString().value : "any";

    if (!node.has("constraint")) {
        node.asObject().put(new Json.JString("constraint", 0, 0), new Json.JString("true", 0, 0));
    }

    annotation.additionalProperties = node.has("additionalProperties") ? node.getOrThrow("additionalProperties", "").asBoolean().value : true;

    annotation.examples = node.has("examples") ? node.asObject().getOrThrow("examples", "").asArray() : new Json.JArray();

    annotation.nonexamples = node.has("nonexamples") ? node.asObject().getOrThrow("nonexamples", "").asArray() : new Json.JArray();

    annotation.indexOn = [];
    if (node.has("indexOn")) {
        var index = node.asObject().getOrThrow("indexOn", "");
        if (index.type == 2 /* JString */) {
            annotation.indexOn = [index.asString().value];
        } else {
            index.asArray().forEach(function (val) {
                annotation.indexOn.push(val.asString().value);
            });
        }
    }

    if (api.metaschema[annotation.type] != undefined) {
        if (api.metaschema[annotation.type].validate(node)) {
            api.metaschema[annotation.type].compile(api);
        } else {
            throw error.validation(node, api.metaschema[annotation.type].validator, "subtree", "annotation.type", tv4.error).on(new Error());
        }
    } else {
        throw error.source(node).message("unknown type '" + annotation.type + "' no metaschema to validate it").on(new Error());
    }

    annotation.constraint = expression.Expression.parseUser(node.asObject().getOrThrow("constraint", "no constraint defined").coerceString());

    annotation.examples.forEach(function (example) {
        var valid = tv4.validate(example.toJSON(), node.toJSON(), true, false);
        if (!valid) {
            throw error.validation(example, node, "example", "schema", tv4.error).on(new Error());
        }
    });

    annotation.nonexamples.forEach(function (nonexample) {
        var valid = tv4.validate(nonexample.toJSON(), node.toJSON(), true, false);
        if (valid) {
            throw error.message("nonexample erroneously passed").source(nonexample).on(new Error());
        }
    });

    return annotation;
}

function fetchRef(url, model) {
    var baseUrl = url;
    var fragment = "";
    if (url.indexOf('#') !== -1) {
        fragment = url.substring(url.indexOf("#") + 1);
        baseUrl = url.substring(0, url.indexOf("#"));
    }
    var pointerPath = decodeURIComponent(fragment);

    if (pointerPath.charAt(0) !== "/") {
        throw error.message("$ref URL not starting with / or #/ " + url).on(new Error());
    }

    var parts = pointerPath.split("/").slice(1);
    var schema = model.schema.json;

    for (var i = 0; i < parts.length; i++) {
        var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
        schema = schema.getOrThrow(component, [
            JSON.stringify(schema.toJSON()),
            "could not find schema at " + component + " of " + pointerPath
        ].join("\n"));
    }

    if (globals.debug)
        console.log("fetchRef" + url + " retrieved " + JSON.stringify(schema.toJSON()));

    return schema;
}
exports.fetchRef = fetchRef;

var SchemaAPI = (function () {
    function SchemaAPI() {
        this.metaschema = {};
        var files = fs.readdirSync(blaze.root + "schema/metaschema");
        for (var i in files) {
            if (!files.hasOwnProperty(i))
                continue;
            var path = blaze.root + "schema/metaschema" + '/' + files[i];
            var metaschema_def = blaze.load_yaml(path);

            var typename = metaschema_def.getOrThrow("name", "meta-schema is not named in: " + path).asString().value;

            console.log("loading type " + typename + " definition from " + path);
            this.metaschema[typename] = MetaSchema.parse(metaschema_def);
        }
    }
    SchemaAPI.prototype.setContext = function (node, parent, annotationInProgress, model) {
        this.link = node;
        this.node = this.link.toJSON();
        this.parent = parent == null ? null : parent.toJSON();
        this.annotationInProgress = annotationInProgress;
        this.model = model;
    };

    SchemaAPI.prototype.addConstraint = function (expression) {
        if (globals.debug)
            console.log("addConstraint " + expression);
        this.link.asObject().put(new Json.JString("constraint", 0, 0), new Json.JString("(" + this.link.getOrThrow("constraint", "constraint not defined").coerceString().value + ") && (" + expression + ")", 0, 0));
    };

    SchemaAPI.prototype.addProperty = function (name, json) {
        throw new Error("redo since refactor, not reflecting change from raw json to Json.JValue");
        this.node[name] = json;

        var extra_annotator = new SchemaAPI();
        extra_annotator.setContext(json, this.node, this.annotationInProgress, this.model);

        this.annotationInProgress.properties[name] = annotate_schema(json, this.node, name, extra_annotator, this.model);
    };

    SchemaAPI.prototype.getField = function (name, type) {
        if (globals.debug)
            console.log("getField on", name, "result:", this.node[name], this.node);
        if (this.node[name] == null)
            return null;

        if (type !== undefined) {
            if (type == 'array') {
                return this.link.getOrThrow(name, "").asArray().toJSON;
            } else if (type == 'object') {
                return this.link.getOrThrow(name, "").asObject().toJSON;
            } else if (type == 'string') {
                return this.link.getOrThrow(name, "").asString().toJSON;
            } else if (type == 'boolean') {
                return this.link.getOrThrow(name, "").asBoolean().toJSON;
            } else if (type == 'number') {
                return this.link.getOrThrow(name, "").asNumber().toJSON;
            } else {
                throw error.message("unrecognised type specified: " + type).on(new Error());
            }
        }

        return this.node[name];
    };

    SchemaAPI.prototype.getWildchild = function () {
        return exports.getWildchild(this.node).value;
    };
    return SchemaAPI;
})();
exports.SchemaAPI = SchemaAPI;

function getWildchild(node) {
    var wildchild = null;
    node.asObject().forEach(function (keyword, child) {
        var name = keyword.value;
        if (name.indexOf("$") == 0 || name.indexOf("~$") == 0) {
            if (wildchild == null)
                wildchild = keyword;
            else {
                throw error.message("multiple wildchilds defined:\n").source(node).on(new Error());
            }
        }
    });
    return wildchild;
}
exports.getWildchild = getWildchild;
//# sourceMappingURL=schema.js.map
